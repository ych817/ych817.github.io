[{"categories":null,"content":"$$ {\\rm \\LaTeX}\\text{ Definitions are here.} \\let\\ph=\\phantom \\let\\hph=\\hphantom \\let\\vph=\\vphantom \\let\\mrel=\\mathrel \\let\\mbin=\\mathbin \\let\\mllap=\\mathllap \\let\\mrlap=\\mathrlap \\let\\mclap=\\mathclap \\def\\verts#1{\\lvert#1\\rvert} \\def\\pila{\\vph{fg}} % 柱子 , 用于指定盒子的最小高度 % ------------------------------------------------------------------ % 类型运算 \\def\\cons{\\mrel{.}} % 对应积类型 concatenation \\def\\ethr{\\mrel{|}} % 对应和类型 either \\def\\etc{{\\rm etc}} % ------------------------------------------------------------------ % + 的值构造器 \\def\\Lft{{\\tt Lft}} % 对象 + 构造器 Left \\def\\Rht{{\\tt Rht}} % 对象 + 构造器 Right % × 的接口 \\def\\fst{{\\tt fst}} % 对象 × - first \\def\\snd{{\\tt snd}} % × - second % N 的值构造器 \\def\\zero{0} % N - zero \\def\\succ{{\\tt succ}} % N - successor % ------------------------------------------------------------------ % 打印方法名 \\def\\id{\\textrm{id}} % 对象的 id \\def\\absurd{{\\rm\\large\\textexclamdown}\\hspace{-3px}} % 对象的 absurd \\def\\bang{{\\rm\\small !}} % 对象的 bang \\def\\dom{\\textrm{dom}} % 箭头的定义域 \\def\\img{\\textrm{img}} % 箭头的值域 \\def\\src{\\textrm{src}} % 箭头的源头 \\def\\tar{\\textrm{tar}} % 箭头的目标 \\def\\ID{\\textrm{ID}} % 范畴的 ID \\def\\Obj{\\textrm{Obj}} % 范畴的对象 \\def\\Arr{\\textrm{Arr}} % 范畴的箭头 \\def\\circH{\\mbin{\\overline\\circ}} % 自然变换的横复合 \\def\\circV{\\mbin{\\circ}} % 自然变换的纵复合 % 打印常/变量名 \\newcommand{\\obj}[1][c]{{\\sf #1}} % 对象 \\def\\obji{\\obj[0]} % 对象 : 始 \\def\\objt{\\obj[1]} % 对象 : 终 \\newcommand{\\cat}[1][C]{\\mathcal{#1}} % 范畴 : C(默认) \\def\\catCat{\\cat[Cat]} % 范畴 : Cat \\def\\catSet{\\cat[Set]} % 范畴 : Set \\def\\catHask{\\cat[Hask]} % 范畴 : Hask — 笛卡尔闭范畴 (+/× 都在里面) \\newcommand{\\catcirc}[1][\\cat]{ % 范畴 C 中的复合运算 \\catbfunc[#1]{\\circ}} \\newcommand{\\catufunc}[2][\\cat]{{ % 范畴 C 中的函子 : 一元 \\overset{\\mclap{\\small\\pila #1}}{#2}}} \\newcommand{\\catbfunc}[2][\\cat]{\\mbin{{ % 范畴 C 中的函子 : 二元 \\overset{\\mclap{\\small\\pila #1}}{#2}}}} \\newcommand{\\catdiag}[1][\\cat]{ % 范畴 C 中的函子 : 对角 \\catufunc[#1]{\\Delta}} \\newcommand{\\cathom}[1][\\cat]{\\mbin{{ % 范畴 C 中的函子 : Hom \\xrightarrow{\\small #1}}}} \\newcommand{\\catplus}[1][\\cat]{ % 范畴 C 中的函子 : + \\catbfunc[#1]{+}} \\newcommand{\\cattimes}[1][\\cat]{ % 范畴 C 中的函子 : × \\catbfunc[#1]{\\times}} \\newcommand{\\catotimes}[1][\\cat]{ % 范畴 C 中的张量积 \\catbfunc[#1]{\\otimes}} \\newcommand{\\list}[1]{ % 范畴 Hask 中的函子 List \\texttt{[\\(#1\\)]}} \\def\\nil{{\\tt []}} % 范畴 Hask 中的函子 List 的值构造器 nil \\def\\concat{\\mbin{:}} % 范畴 Hask 中的函子 List 的值构造器 concat \\def\\yoneda{{\\Large\\raise{-1px}{ % 米田嵌入 \\hspace{-1px}\\smash{よ}\\vph{(fgh)}\\hspace{-1px}}}} \\def\\yoda{ % 尤达嵌入 \\texttt{尤}} \\def\\limit#1{{\\rm lim}} % 极限 \\def\\colimit#1{{\\rm colim}} % 余极限 % 用方法求值 \\def\\getid#1{{}_{:#1}\\id} % 获取对象的 id \\def\\getabsurd#1{{}_{:#1}\\absurd} % 获取对象的 absurd \\def\\getbang#1{{}_{:#1}\\bang} % 获取对象的 bang \\def\\getdom#1{#1\\textrm{ dom}} % 获取箭头的定义域 \\def\\getimg#1{#1\\textrm{ img}} % 获取箭头的值域 \\def\\getsrc#1{#1~\\src} % 获取箭头的源头 \\def\\gettar#1{#1~\\tar} % 获取箭头的目标 \\def\\getrst#1undr#2{{}^{\\vph{fg}}_{:#2}{#1}} % 获取箭头在对象下的限制 \\def\\getID#1{{}_{:#1}\\ID} % 获取范畴的 ID \\def\\getObj#1{#1~\\Obj} % 获取范畴的对象 \\def\\getArr#1{#1~\\Arr} % 获取范畴的箭头 \\def\\getop#1{#1^{\\rm op}} % 获取范畴的对偶 \\def\\getlimit#1{#1\\textrm{ lim}} % 获取极限 \\def\\getcolimit#1{#1\\textrm{ colim}} % 获取余极限 $$ 章节 01 - 03 范畴由对象以及对象间的箭头构成 。本文将会 着重分析余积闭范畴 $\\cat$ 。 现在先给出下述定义 : $\\obji$ 为始对象当且仅当对任意 $\\cat$ 中对象 $\\obj$ 都有且仅有唯一的箭头 $\\getabsurd{\\obj}: \\obji\\cathom \\obj$ $\\objt$ 为终对象当且仅当对任意 $\\cat$ 中对象 $\\obj$ 都有且仅有唯一的箭头 $\\getbang{\\obj}: \\obj \\cathom \\objt$ 注意 其他范畴中始 / 终对象未必存在 。 我们假设范畴 $\\cat$ 中含有始对象 $\\obj[0]$ 以及终对象 $\\obj[1]$ 。 因此根据上面的的信息我们不难得出下述内容 : 形如 $\\obji\\cathom\\obji$ 的箭头 仅有一个 , 即 $\\getid\\obji$ 形如 $\\objt\\cathom\\objt$ 的箭头 仅有一个 , 即 $\\getid\\objt$ 对任意 $\\cat$ 中对象 $\\obj[a]$ , $\\obj[a_1]$ , $\\obj[a_2]$ , $\\etc$ , $\\obj[b]$ , $\\obj[b_1]$ , $\\obj[b_2]$ , $\\etc$ 及任意 $\\cat$ 中映射 $\\phi$ 我们规定下述性质始终成立 : 。 $\\phi$ 为 $\\obj[b]$ 的元素当且仅当 $\\phi: \\obj[a]\\cathom\\obj[b]$ $\\phi$ 为 $\\obj[a]$ 的全局元素当且仅当 $\\phi: \\objt\\cathom\\obj[a]$ $\\phi$ 不存在可由 $\\phi: \\obj[b]\\cathom \\obji$ 得出 注意 其他范畴中上一条断言未必成立 。 另外我们规定 $\\obj[a]\\cathom\\obj[b]$ 为所有 从 $\\obj[a]$ 射向 $\\obj[b]$ 的箭头构成的集 注意 上述断言仅对局部小范畴成立 其他范畴里 $\\obj[a]\\cathom\\obj[b]$ 未必为集合 。 范畴 $\\cat$ 中某些特定的箭头可进行复合运算 : 对任意 $\\cat$ 中对象 $\\ob","date":"2025-04-18","objectID":"/posts/24198cb/:0:0","tags":["总结","DaoFP","函数式编程","Haskell"],"title":"总结-DaoFP-范畴论","uri":"/posts/24198cb/"},{"categories":null,"content":"Hello ","date":"2025-04-03","objectID":"/posts/d83fb0b/:0:0","tags":["翻译","EOPL","函数式编程","Racket","Lisp"],"title":"翻译-EOPL-05","uri":"/posts/d83fb0b/"},{"categories":null,"content":"Hello ","date":"2025-04-03","objectID":"/posts/a588704/:0:0","tags":["翻译","EOPL","函数式编程","Racket","Lisp"],"title":"翻译-EOPL-04","uri":"/posts/a588704/"},{"categories":null,"content":"$$ \\rm\\LaTeX\\textrm{ Definitions are here.} \\def\\Int{\\textrm{Int}} \\def\\Expression{\\textrm{Expression}} \\def\\SList{\\textrm{S-list}} \\def\\SExp{\\textrm{S-exp}} \\def\\Symbol{\\textrm{Symbol}} \\def\\Bintree{\\textrm{Bintree}} \\def\\LcExp{\\textrm{LcExp}} \\def\\Iden{\\textrm{Identifier}} \\def\\BinSearchTree{\\textrm{Binary-search-tree}} \\def\\InductHyp{\\textit{IH}} \\def\\List{\\textrm{List}} \\def\\ScmVal{\\textrm{Scheme\\_value}} \\def\\ListOfInt{\\textrm{List-of-Int}} \\def\\ListOfSymbol{\\textrm{List-of-Symbol}} \\def\\ListOf#1{\\textrm{List-of-(#1)}} \\def\\VectorOf#1{\\textrm{Vector-of(#1)}} \\def\\implement#1{\\lceil#1\\rceil} \\def\\DiffTree{\\textrm{Diff-Tree}} \\def\\EnvExp{\\textrm{Env-exp}} \\def\\Var{\\textrm{Var}} \\def\\Bool{\\textrm{Bool}} \\def\\NodeInSeq{\\textrm{NodeInSequence}} \\def\\RedBlueTree{\\textrm{Red-blue-tree}} \\def\\RedBlueSubtree{\\textrm{Red-blue-subtree}} \\def\\PrefixList{\\textrm{Prefix-list}} $$2.1 通过接口声明数据 每当我们以某种方式描述集合时 , 一种新数据类型便会随之产生 。 对这些数据类型下的实体而言 , 其值为其外在的表示 , 而基于其的运算便是处理这些实体的过程 。 这些实体的表示通常会很复杂 。如果允许的话 , 我们不会关心它们具体的实现细节 , 但是我们可能会改变数据的表示 。完美的表示往往难以实现 , 因此我们会先尝试一些简单的实现 , 只有在系统整体性能与之攸关时才改用更高效的表示 。 如果决定要改变某些数据的表示方式 , 我们需要能定位出程序中所有依赖该表示的部分 。 这就需要借助数据抽象 data abstraction 技术 。 数据抽象将数据类型分为两部分 : 接口 interface 和实现 implementation 。接口告诉我们类型表示什么数据 , 数据可进行什么操作 , 这些操作可得出什么性质 , 等等 ; 而实现则会给出数据的具体表示以及处理数据表示的代码 。 这样抽象出的数据类型称作抽象数据类型 abstract data type 。程序的其余部分 ( 即数据类型 的用户 client ) 只能通过接口中指定的操作来处理新数据 。这样一来如果希望改变数据的表示 我们只需改变数据处理接口的实现即可 。 这一想法并不陌生 : 我们写程序处理文件时一般只关心能否调用过程以对文件进行打开 , 关闭 , 读取或其他操作 。同样地在大多数时候我们并不关心整数在机器中究竟怎样表示 , 只关心能否 可靠地执行算术操作 。 如果数据类型下的项只能通过接口提供的过程进行处理, 那么我们便可将代码称作表示无关的 representation independent —— 因为这些代码不依赖这些项的值的表示 。 如此所有关于数据表示的信息必然在实现对应的代码之中 ; 实现中最重要的部分便是声明数据 的表示方式 。我们用记号 $\\implement v$ 表示 \" $v$ 的表示 \" 。 为使这一切更明了 , 考虑一个简单的例子 —— 自然数类型 : 待表示数据为自然数 , 接口由四个 过程组成 : zero , is-zero? , successor , predecessor ; 当然不是随便几个过程都能够 作为该接口的实现 , 一组过程只有同时满足下述四个方程才可作为下述接口的实现 : $\\qquad \\begin{aligned}[t] \u0026\\texttt{(zero)} \u0026{}={} \u0026\\implement 0 \\\\ \u0026\\texttt{(is-zero? \\implement {$n$})} \u0026{}={} \u0026\\begin{cases} \\texttt{\\#t} \u0026 n=0 \\\\ \\texttt{\\#f} \u0026 n\\neq 0 \\end{cases} \\\\ \u0026\\texttt{(successor \\implement {$n$})} \u0026{}={} \u0026\\implement{n+1} \u0026 (n\\geq 0) \\\\ \u0026\\texttt{(predecessor \\implement {$n+1$})} \u0026{}={} \u0026\\implement{n} \u0026 (n\\geq 0) \\end{aligned}$ 该定义并未指明自然数应当如何表示 , 它只要求这些过程产生指定的行为 —— 如 zero 必须 返回 0 的表示 , successor 须返回 n+1 的表示 , 等等 ; 该定义并没有对 zero 做出说明 , 所以按照该定义任何行为都是可接受的 。 现在我们可以写出处理自然数的用户程序 , 并且不论用哪种表示方式都可以保证得出正确结果 。如 , (define plus (lambda (x y) (if (is-zero? x) y (successor (plus (predecessor x) y))))) 都将满足 $\\texttt{(plus \\implement {$x$} \\implement {$y$})} = \\implement {x+y}$ , 无论采用的表示方式为如何 。 大多数接口都包含若干用于创建数据类型的元素的构造器 constructor 及若干用于从数据类型 的元素中提取信息的观测器 observer 。这里也不例外 : 有三个构造器 zero , successor 及 predecessor 外加一个观测器 is-zero? 。 可以用多种方式表示这套接口 。我们考虑其中三种 : 一元表示法 Unary representation : 在一元表示法中自然数 n 表示为 n 个 #t 构成的列表 ; 如此 $\\qquad \\begin{aligned}[t] \u0026\\implement 0 \u0026{}={} \u0026\\texttt{()} \\\\ \u0026\\implement 1 \u0026{}={} \u0026\\texttt{(\\#t)} \\\\ \u0026\\implement 2 \u0026{}={} \u0026\\texttt{(\\#t \\#t)} \\end{aligned}$ 如此便可递归定义该表示法 : $\\qquad \\begin{aligned}[t] \u0026\\implement 0 \u0026{}={} \u0026\\texttt{()} \\\\ \u0026\\implement {n+1} \u0026{}={} \u0026\\texttt{(\\#t . n)} \\\\ \\end{aligned}$ 在该表示法中我们可通过下述代码实现接口 (define zero (lambda () '())) (define is-zero? (lambda (n) (null? n))) (define successor (lambda (n) (cons #t n))) (define predecessor (lambda (n) (cdr n))) Scheme 数字表示法 Scheme number representation : 该表示仅涉及 Scheme 内置的数字表示法 ( 本身可能十分复杂 ! ) 。 如果令 $\\implement n$ 为 Scheme 整数 $n$ , 则所需的四个过程可以定义为： (define zero (lambda () 0)) (define is-zero? (lambda (n) (zero? n))) (define successor (lambda (n) (+ n 1))) (define predecessor (lambda (n) (- n 1))) 大数表示法 Bignum representation : 此表示法中数值以 $N$ 进制表示 , 其中 $N$ 是某个整数 ; 该方法以 $0$ 到 $N-1$ 之间的数字 ( 有时不称数位而称大位 bigit ) 组成的表来表示数值 , 这就很容易表示那些远超机器字长 的整数 。为了便使用 , 这里把最低位放在列表最前端 。该表示法可通过归纳法如下定义 : $\\qquad \\begin{aligned}[t] \u0026\\implement n \u0026{}={} \u0026 0 \u0026\u0026 \\textrm{若 $n=0$} \\\\ \u0026\u0026 \u0026 \\texttt{(r . \\implement {$q$})} \u0026\u0026\\textrm{若 $n=qN+r$ 且 $0\\leq r \u003c N$} \\end{aligned}$ 因此若 $N=16$ 则 $\\implement {33}=\\texttt{(1 2)}$ 且 $\\implement {258} =\\texttt{(2 0 1)","date":"2025-04-02","objectID":"/posts/1568c34/:0:0","tags":["翻译","EOPL","函数式编程","Racket","Lisp"],"title":"翻译-EOPL-02-数据抽象","uri":"/posts/1568c34/"},{"categories":null,"content":"$$ \\rm\\LaTeX\\textrm{ Definitions are here.} \\def\\Int{\\textrm{Int}} \\def\\Expression{\\textrm{Expression}} \\def\\SList{\\textrm{S-list}} \\def\\SExp{\\textrm{S-exp}} \\def\\Symbol{\\textrm{Symbol}} \\def\\Bintree{\\textrm{Bintree}} \\def\\LcExp{\\textrm{LcExp}} \\def\\Iden{\\textrm{Identifier}} \\def\\BinSearchTree{\\textrm{Binary-search-tree}} \\def\\InductHyp{\\textit{IH}} \\def\\List{\\textrm{List}} \\def\\ScmVal{\\textrm{Scheme\\_value}} \\def\\ListOfInt{\\textrm{List-of-Int}} \\def\\ListOfSymbol{\\textrm{List-of-Symbol}} \\def\\ListOf#1{\\textrm{List-of-(#1)}} \\def\\VectorOf#1{\\textrm{Vector-of(#1)}} \\def\\implement#1{\\lceil#1\\rceil} \\def\\DiffTree{\\textrm{Diff-Tree}} \\def\\EnvExp{\\textrm{Env-exp}} \\def\\N{\\mathbb{N}} $$解释器、检查器及其他类似程序是编程语言处理器的核心 。本章将介绍这些程序用到的基本编程工具 。 由于编程语言的语法通常具有嵌套或树状结构 , 因此递归将成为我们的主要手段 。1.1 节及 1.2 节将介绍递归定义数据结构的方法 并展示如何利用这类定义来指导递归程序的构建 ; 而 1.3 节 则会介绍如何将这些技术推广到更复杂的问题上 。 本章末尾提供了大量练习 , 它们是本章的核心内容 : 它们能为掌握 递归编程技巧提供必要的实践经验 , 而这正是阅读后续内容所依赖的 。 1.1 递归定义的数据 在书写一段程序或一个过程时你必须清楚地认识到 : 什么样的值能作为过程的实参 , 而什么样的值又能作为合法的返回值 。 这些值构成的集通常很复杂 。本节将介绍定义这些集合的形式化技术 。 1.1.1 递归定义 递归定义 Inductive specification 是一种定义集合的强大方法 。为了介绍它 我们先试着用它描述自然数 $\\N=\\{0,1,2,\\ldots\\}$ 的某一子集 $S$ 。 定义 1.1.1 规定 $n\\in S$ 当且仅当 $n=0$ , 或者 $n-3\\in S$ 看看如何用上述定义判断哪些自然数会落在 $S$ 中 。 首先由 $0\\in S$ 可知 $3\\in S$ ( 因为 $3-3=0\\in S$ ) , 另外 $6\\in S$ ( 因为 $6-3=3\\in S$ ) 。继续这样做下去便可得知 所有能被 $3$ 整除的自然数都落在 $S$ 中 。 那其他自然数呢 ? $1\\in S$ 是否成立呢 ? 首先由 $1\\neq 0$ 可知条件 1 不成立 ; 另外 $1-3=-2$ 非自然数 , 故 $-2$ 非 $S$ 中元素 , 条件 2 也不成立 ; 既然两个条件对 $1$ 都不成立 , 故 $1\\notin S$ 。 同样地我们有 $2\\notin S$ 。 那 $4$ 呢 ? $4\\in S$ 当且仅当 $1\\in S$ , 但 $1\\notin S$ , 从而 $4\\notin S$ 。用类似的方法不难得知 : 若 $n$ 是自然数并且 $n$ 非 $3$ 倍数则 $n\\notin S$ 。 综上 $S$ 便是所有能被 $3$ 整除的自然数所构成的集 。 我们可根据定义 1.1.1 编写一个过程以判断自然数是否落在 $S$ 中 : ;; 过程合约 : in-S? : Natural → Bool ;; 过程用途 : (in-S? n ) = #t 仅当 n 属于 S 的话 , 否则为 #f ;; 实参语法 : Natural ::= 0 | (succ Natural) (define in-S? (lambda (n) (if (zero? n) #t (if (\u003e= (- n 3) 0) (in-S? (- n 3)) #f)))) 刚才我们根据定义 1.1.1 编写了一个递归过程 , 代码中的 in-S? : Natural → Bool 是一条注释 , 称作过程的合约 contract : 它表示过程 in-S? 应以一个以自然数为实参并返回一个布尔值 。 这样的注释对阅读和编写代码很有帮助 。 在判断 $n\\in S$ 是否成立前 , 首先应判断 $n=0$ 是否成立 : 如果成立则返回真 , 否则则需要判断 $n-3\\in S$ 是否成立 ; 要实现后者首先需判断 $n-3\\geq 0$ 是否为真 : 若为真则可调用上述过程判断其是否属于 $S$ , 否则 $n\\notin S$ 。 下面是另一种定义 $S$ 的方法 。 定义 1.1.2 规定 $S$ 为自然数 $\\N$ 子集且为满足下述条件的最小集 : $0\\in S$ 若 $n\\in S$ 则 $n+3\\in S$ 刚才的 \" 最小集 \" 意味着该集合不仅满足上述两条性质 , 并且还是其他任何满足上述两条性质的集的子集 。 很明显这样的集唯一 : 如果 $S_1$ , $S_2$ 都满足上述条件且都为最小集 , 那么 $S_1\\subseteq S_2$ ( 因为 $S_1$ 是最小集 ) 并且 $S_1\\supseteq S_2$ ( 因为 $S_2$ 是最小集 ) , 如此 $S_1=S_2$ 。该条件不可或缺 , 否则 $S$ 就不唯一了 ( 见练习 1.3 ) 。 下面是上述定义的另一种记法 : $\\begin{prooftree} \\AXC{} \\UIC{$0\\in S$} \\end{prooftree}$ $\\begin{prooftree} \\AXC{$n\\in S$} \\UIC{$(n+3)\\in S$} \\end{prooftree}$ 这不过是定义 1.1.2 的简便记法罢了 。上面的每个公式称作推理规则 rule of inference , 简称规则 rule ; 水平线可以被解释为 \" 若 . . . 则 . . . \" ; 水平线上方的部分称作假设 hypothesis 或者是前件 antecedent , 下方部分则称作是结论 conclusion 或者是后件 consequent 。若有多个假设 , 则使用隐藏的 \" 且 \" ( 见 定义 1.1.5 ) 来连接它们 ; 没有假设的规则称作公理 axiom , 在书写公理时常常会省略水平线 , 即 $\\qquad\\begin{prooftree} \\AXC{$0\\in S$} \\end{prooftree}$ 上述两条规则可解释为如下 : \" 自然数 $n$ 属于 $S$ 当且仅当断言 ’ $n\\in S$ ’ 可通过在公理上有限次地应用 推理规则得出 \" 。这一解释使得 $S$ 可以很自然地被人理解为闭合于该规则的最小集合 。 刚才的两个定义描述的都是同一个对象 。我们通常会把版本 1 称作是自顶向下 top-down 的 , 并且把 版本 2 称作是自底向上 bottom-up 的 。版本 3 则称作是推理规则 rules-of-inference 形式的 。 来看看上述三种定义方式在其他例子中的使用 。 定义 1.1.3 ( 整数列表 , 自顶向下 ) Scheme 中的列表为整数列表当且仅当其 要么是空列表 要么是个配对 , 满足 car 为自然数且 cdr 为整数列表 定义 1.1.4 ( 整数列表 , 自底向上 ) $\\ListOfInt$ 为满足下述条件的最小集 : $\\texttt{()}\\in \\ListOfInt$ , 并且 若 $n\\in \\Int$ 并且 $l\\in \\ListOfInt$ 则 $\\texttt{($n$ . $l$)}\\in \\ListOfInt$ 这里我们用中缀符 \" $\\texttt{.}$ \" 来代表 Scheme 中 cons 的输出结果 ; 语句 $\\texttt{($n$ . $l$)}$ 表示一个头 ( car ) 为 $n$ 且尾 ( cdr ) 为 $l$ 的 Scheme 序对 。 定义 1.1.5 ( 整数列表 , 推理规则 ) $\\begin{prooftree} \\AXC{$\\texttt{()} \\in \\ListOfInt$} \\end{prooftree}$ $\\begin{prooftree} \\AXC{$n\\in \\Int$} \\AXC{$l\\in \\ListOfInt$} \\BIC{$\\texttt{($n$ . $l$)}\\in \\ListOfInt$} \\end{prooftree}$ 上述三种定义是彼此等价的 。 接下来我们来看看如何用这些定义来生成整数列表 。 $\\texttt{()}$ 是整数列表 , 由定义 1.1.4 / 定义 1.1.5 的条件 1 可得知 ; $\\texttt{(14 . ())}$ 是整数列表 —— 由于 $\\texttt{14}$ 是整数且 $\\texttt{()}$ 是 整数列表 , 如此利用定义 1.","date":"2025-04-02","objectID":"/posts/5cce8df/:0:0","tags":["翻译","EOPL","函数式编程","Racket","Lisp"],"title":"翻译-EOPL-01-递归的数据集","uri":"/posts/5cce8df/"},{"categories":null,"content":"泥壕ni hao ! 我是沉积岩 , 来自采石场 。 ","date":"2025-03-26","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"数学公式 MathJax 配置 配置流程 下述操作参考链接在此1 。 首先将 ./themes/FixIt/layouts/partials/assets.html 复制到 ./layouts/partials/assets.html , 然后将其中与 KaTeX 中的内容删除 , 并把下述内容粘贴进该文件中 : {{- /* MathJax */ -}} {{- $math := .Scratch.Get \"math\" -}} {{- if $math.enable -}} \u003cscript\u003e MathJax = { loader: { load: ['[custom]/xypic.js'], paths: { custom: 'https://cdn.jsdelivr.net/gh/sonoisa/XyJax-v3@3.0.1/build/' } }, tex: { packages: { '[+]': ['xypic'] }, inlineMath: [['\\\\(', '\\\\)'], ['$', '$']], displayMath: [['\\\\[', '\\\\]'], ['$$', '$$']], processEscapes: true, // processEnvironments: true, useLabelIds: true }, options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'], enableMenu: false, } }; \u003c/script\u003e \u003cscript type=\"text/javascript\" id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js\"\u003e\u003c/script\u003e \u003cstyle\u003e mjx-container { display: inline-grid; overflow-x: auto; overflow-y: hidden; max-width: 100%; } mjx-container svg { display: inline-grid !important; overflow-x: auto; overflow-y: hidden; max-width: 100%; } \u003c/style\u003e {{- end -}} 为使行内公式能正确加载 , 我们还需允许 passthrough render hooks2 。 具体配置参考官方文档2 。 测试结果 行间公式测试 : $$ \\rm\\LaTeX\\text{ definitions are here.} \\let\\ph=\\phantom \\let\\vph=\\vphantom \\def\\pila{\\vph{fg}} $$ 行内公式测试 : $c = \\pm\\sqrt{a^2 + b^2}$ 和 $\\displaystyle f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi$ 以及 $x^2 +y^2=1$ 、 $ \\begin{array}{|l|l|}\\hline \\cellcolor{LightGreen} \\rm Hello \u0026 \\rm World\\pila \\\\\\hline \\end{array} $ 。 $ % \\begin{array}{l} % \\qquad~~\\begin{xy}0;p+/r+1cm/: % (-1,+.75)*++\u003c3pt\u003e[F-:\u003c10pt\u003e:Gray][=stateOld]{}=\"MaI1\"; % (-1,-.75)*[stateOld]{}=\"MaIn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}} % ?(.5)=\"MaL\"*[gray]!L{\\small I_a};\"MaL\". % \"MaIn\".\"MaI1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MaI\"; % (+1,+.75)*++\u003c3pt\u003e[F=:\u003c10pt\u003e:Gray][=stateOldFin]{}=\"MaF1\"; % (+1,-.75)*[stateOldFin]{}=\"MaFn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}}, % ,?(.5)=\"MaR\"*[gray]!R{\\small F_a};\"MaR\". % \"MaFn\".\"MaF1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MaF\"; % \"MaL\";\"MaR\"**@{}?(.5)*[gray]{\\small M_a}. % \"MaF\".\"MaI\"*+\u003c4pt\u003e[F-:\u003c5pt\u003e]\\frm{}=\"Ma\"; % % ----------------------------------------------------------- % \"MaI1\"!L;\"MaIn\"!L**@{} % @={?(0),?(.25),?(.5),?(.75),?(1)} % @@{\\ar@[gray]@{-\u003e}@`{c+/l+1.5pc/,c}c}; % % ----------------------------------------------------------- % (5.15,0);p+/r+1cm/: % % ----------------------------------------------------------- % (-1,+.75)*[stateOld]{}=\"MbI1\"; % (-1,-.75)*[stateOld]{}=\"MbIn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}} % ?(.5)=\"MbL\"*[gray]!L{\\small I_b};\"MbL\". % \"MbIn\".\"MbI1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MbI\"; % (+1,+.75)*[stateOldFin]{}=\"MbF1\"; % (+1,-.75)*[stateOldFin]{}=\"MbFn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}}, % ,?(.5)=\"MbR\"*[gray]!R{\\small F_b};\"MbR\". % \"MbFn\".\"MbF1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MbF\"; % \"MbL\";\"MbR\"**@{}?(.5)*[gray]{\\small M_b}. % \"MbF\".\"MbI\"*+\u003c4pt\u003e[F-:\u003c5pt\u003e]\\frm{}=\"Mb\"; % % ----------------------------------------------------------- % \"MbI1\"!L;\"MbIn\"!L**@{} % @={?(0),?(.25),?(.5),?(.75),?(1)} % @@{\\ar@[gray]@{-\u003e}@`{c+/l+1.5pc/,c}c}; % \\end{xy} % \\\\ % \\begin{xy}p+/r+1cm/:p+/u+1cm/:: % (-2.5,-1.375)*++\u003c3pt\u003e[F-:\u003c10pt\u003e][=stateNew]{}=\"p\", % {\\ar@{.\u003e}@`{c+/l+3pc/,\"p\"}\"p\"}; % % ------------------------------------------------------- % (-1,+.75)*++\u003c3pt\u003e[F-:\u003c10pt\u003e:Gray][=stateOld]{}=\"MaI1\"; % (-1,-.75)*[stateOld]{}=\"MaIn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}} % ?(.5)=\"MaL\"*[gray]!L{\\small I_a};\"MaL\". % \"MaIn\".\"MaI1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MaI\"; % (+1,+.75)*++\u003c3pt\u003e[F=:\u003c10pt\u003e:Gray][=stateOldFin]{}=\"MaF1\"; % (+1,-.75)*[stateOldFin]{}=\"MaFn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}}, % ,?(.5)=\"MaR\"*[gray]!R{\\small F_a};\"MaR\". % \"MaFn\".\"MaF1\"*+\u003c8pt,5pt\u003e[F:\u003c3pt\u003e]\\frm{}=\"MaF\"; % \"MaL\";\"MaR\"**@{}?(.5)*[gray]{\\small M_a}. % \"MaF\".\"MaI\"*+\u003c4pt\u003e[F-:\u003c5pt\u003e]\\frm{}=\"Ma\"; % % ----------------------------------------------------------- % (0,-2.75);p+/r+1cm/: % (-1,+.75)*[stateOld]{}=\"MbI1\"; % (-1,-.75)*[stateOld]{}=\"MbIn\"**@{} % @={?(.35),?(.5),?(.65)} @@{*{\\cdot}} % ?(.5)=\"M","date":"2025-03-24","objectID":"/posts/config-hugo_fixit/:0:0","tags":["HUGO","博客"],"title":"Hugo FixIt 主题配置","uri":"/posts/config-hugo_fixit/"}]